//! # 04: Resources and Prompts - Serving Data and AI Integration
//!
//! **Learning Goals (15 minutes):**
//! - Create resource handlers to serve data
//! - Build prompt handlers for AI assistants
//! - Understand URI patterns for resources
//! - Learn prompt argument handling
//!
//! **Prerequisites:** 01_hello_world_macro.rs, 03_tools_and_parameters.rs
//!
//! **Run with:** `cargo run --example 04_resources_and_prompts`

use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use turbomcp::{McpResult, RequestContext, prompt, resource, server, tool};

/// Knowledge base server with resources and prompts
#[derive(Clone)]
struct KnowledgeServer {
    documents: Arc<Mutex<HashMap<String, String>>>,
}

#[server(
    name = "KnowledgeBase",
    version = "1.0.0",
    description = "Tutorial 04: Resources and prompts for data serving"
)]
impl KnowledgeServer {
    fn new() -> Self {
        let mut docs = HashMap::new();
        docs.insert(
            "readme".to_string(),
            "# TurboMCP\nHigh-performance MCP framework".to_string(),
        );
        docs.insert(
            "guide".to_string(),
            "## Getting Started\n1. Install TurboMCP\n2. Create server\n3. Run!".to_string(),
        );

        Self {
            documents: Arc::new(Mutex::new(docs)),
        }
    }

    #[tool("Store a document")]
    async fn store_document(&self, name: String, content: String) -> McpResult<String> {
        let mut docs = self.documents.lock().unwrap();
        docs.insert(name.clone(), content);
        Ok(format!("Stored document: {}", name))
    }

    #[resource("docs://list")]
    async fn list_documents(&self, _uri: String) -> McpResult<String> {
        let docs = self.documents.lock().unwrap();
        let list: Vec<String> = docs.keys().cloned().collect();
        Ok(list.join("\n"))
    }

    #[resource("docs://content/{name}")]
    async fn get_document(&self, uri: String) -> McpResult<String> {
        // Extract document name from URI
        let name = uri.strip_prefix("docs://content/").unwrap_or("unknown");

        let docs = self.documents.lock().unwrap();
        docs.get(name)
            .cloned()
            .ok_or_else(|| turbomcp::McpError::Resource(format!("Document '{}' not found", name)))
    }

    #[prompt("Generate documentation summary")]
    async fn summarize_docs(
        &self,
        _ctx: RequestContext,
        args: Option<serde_json::Value>,
    ) -> McpResult<String> {
        let doc_name = args
            .as_ref()
            .and_then(|v| v.get("document"))
            .and_then(|v| v.as_str())
            .unwrap_or("all");

        if doc_name == "all" {
            Ok("Summarize all documents in the knowledge base:\n\
                - Use bullet points for key information\n\
                - Keep it concise\n\
                - Highlight important concepts"
                .to_string())
        } else {
            Ok(format!(
                "Summarize the '{}' document:\n\
                - Extract main points\n\
                - Identify key concepts\n\
                - Provide brief overview",
                doc_name
            ))
        }
    }

    #[prompt("Answer questions about documentation")]
    async fn answer_question(
        &self,
        _ctx: RequestContext,
        args: Option<serde_json::Value>,
    ) -> McpResult<String> {
        let question = args
            .as_ref()
            .and_then(|v| v.get("question"))
            .and_then(|v| v.as_str())
            .unwrap_or("How do I get started?");

        Ok(format!(
            "Based on the documentation, answer this question:\n\n{}\n\n\
            Provide a clear, helpful response with examples if appropriate.",
            question
        ))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logging
    tracing_subscriber::fmt().with_env_filter("info").init();

    tracing::info!("üìö Starting Tutorial 04: Resources and Prompts");
    tracing::info!("This server demonstrates:");
    tracing::info!("  - Resource handlers for serving data");
    tracing::info!("  - Prompt handlers for AI integration");
    tracing::info!("  - URI pattern matching");
    tracing::info!("  - Argument extraction");

    let server = KnowledgeServer::new();

    // The run_stdio method is generated by the #[server] macro
    server.run_stdio().await?;

    Ok(())
}

// üéØ **Try it out:**
//
//    Run the server:
//    cargo run --example 04_resources_and_prompts
//
//    Then test with Claude Desktop:
//    - Tool: store_document { "name": "tutorial", "content": "..." }
//    - Resource: docs://list
//    - Resource: docs://content/readme
//    - Prompt: summarize_docs { "document": "guide" }
//    - Prompt: answer_question { "question": "How to install?" }

/* üìù **Key Concepts:**

**Resources:**
- Serve data via URI patterns
- Support pattern matching (e.g., {name})
- Return text, JSON, or binary data
- Cached by clients for efficiency

**Prompts:**
- Provide context for AI assistants
- Accept optional arguments
- Return instructional text
- Guide AI behavior and responses

**URI Patterns:**
- Static: "docs://list"
- Dynamic: "docs://content/{name}"
- Hierarchical: "docs://folder/subfolder/file"

**Best Practices:**
- Use resources for data retrieval
- Use prompts for AI instructions
- Keep URIs intuitive and RESTful
- Validate arguments carefully

**Next Steps:**
- Continue to 05_error_handling.rs
- Learn about error patterns
- Explore recovery strategies
*/
