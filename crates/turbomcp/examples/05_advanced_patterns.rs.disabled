#![allow(dead_code)]
//! # 05: Advanced Patterns - Production-Ready Error Handling & Async Patterns
//!
//! **Learning Goals (25 minutes):**
//! - Master robust error handling strategies
//! - Learn advanced async patterns and concurrency
//! - Understand input validation and sanitization
//! - See retry logic and circuit breaker patterns
//! - Implement proper resource cleanup and cancellation
//!
//! **What this example demonstrates:**
//! - Comprehensive error handling with context
//! - Advanced async patterns (timeouts, cancellation, parallelization)
//! - Input validation with custom validators
//! - Retry logic with exponential backoff
//! - Circuit breaker pattern for external services
//! - Resource management and cleanup
//! - Performance monitoring and metrics
//!
//! **Run with:** `cargo run --example 05_advanced_patterns`

use serde::{Deserialize, Serialize};
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::time::{sleep, timeout};
use turbomcp::prelude::*;

/// Advanced server demonstrating production-ready patterns
#[derive(Debug, Clone)]
struct AdvancedPatternsServer {
    /// Circuit breaker for external API calls
    circuit_breaker: Arc<tokio::sync::Mutex<CircuitBreakerState>>,
    /// Metrics collection
    metrics: Arc<tokio::sync::RwLock<ServerMetrics>>,
    /// Active operations for cancellation
    active_operations: Arc<
        tokio::sync::RwLock<std::collections::HashMap<String, tokio::sync::oneshot::Sender<()>>>,
    >,
}

#[derive(Debug)]
struct CircuitBreakerState {
    failures: u32,
    last_failure: Option<Instant>,
    state: CircuitState,
}

#[derive(Debug, Clone, Copy)]
enum CircuitState {
    Closed,   // Normal operation
    Open,     // Failing, reject requests
    HalfOpen, // Testing if service recovered
}

#[derive(Debug, Default)]
struct ServerMetrics {
    requests_total: u64,
    requests_successful: u64,
    requests_failed: u64,
    average_duration: Duration,
}

#[derive(Debug, Deserialize, Serialize)]
struct ApiRequest {
    url: String,
    method: Option<String>, // GET, POST, PUT, DELETE
    headers: Option<std::collections::HashMap<String, String>>,
    body: Option<String>,
    timeout_seconds: Option<u64>,
    retry_attempts: Option<u32>,
}

#[derive(Debug, Deserialize, Serialize)]
struct ValidationRules {
    min_length: Option<usize>,
    max_length: Option<usize>,
    pattern: Option<String>, // regex pattern
    required: Option<bool>,
    allowed_values: Option<Vec<String>>,
}

#[derive(Debug, Deserialize, Serialize)]
struct ProcessingTask {
    task_type: String, // "cpu_intensive", "io_bound", "network"
    data: serde_json::Value,
    timeout_seconds: Option<u64>,
    parallel: Option<bool>,
    chunks: Option<usize>,
}

#[turbomcp::server(name = "AdvancedPatternsServer", version = "1.0.0")]
impl AdvancedPatternsServer {
    fn new() -> Self {
        Self {
            circuit_breaker: Arc::new(tokio::sync::Mutex::new(CircuitBreakerState {
                failures: 0,
                last_failure: None,
                state: CircuitState::Closed,
            })),
            metrics: Arc::new(tokio::sync::RwLock::new(ServerMetrics::default())),
            active_operations: Arc::new(tokio::sync::RwLock::new(std::collections::HashMap::new())),
        }
    }

    /// Update circuit breaker state based on operation result
    async fn update_circuit_breaker(&self, success: bool) {
        let mut breaker = self.circuit_breaker.lock();

        match success {
            true => {
                breaker.failures = 0;
                breaker.state = CircuitState::Closed;
            }
            false => {
                breaker.failures += 1;
                breaker.last_failure = Some(Instant::now());

                if breaker.failures >= 5 {
                    breaker.state = CircuitState::Open;
                }
            }
        }
    }

    /// Check if circuit breaker allows operation
    async fn circuit_breaker_allows(&self) -> bool {
        let mut breaker = self.circuit_breaker.lock();

        match breaker.state {
            CircuitState::Closed => true,
            CircuitState::Open => {
                // Check if we should try half-open
                if let Some(last_failure) = breaker.last_failure {
                    if last_failure.elapsed() > Duration::from_secs(30) {
                        breaker.state = CircuitState::HalfOpen;
                        true
                    } else {
                        false
                    }
                } else {
                    false
                }
            }
            CircuitState::HalfOpen => true,
        }
    }

    /// Record metrics for an operation
    async fn record_metrics(&self, duration: Duration, success: bool) {
        let mut metrics = self.metrics.write();
        metrics.requests_total += 1;

        if success {
            metrics.requests_successful += 1;
        } else {
            metrics.requests_failed += 1;
        }

        // Simple moving average (in production, use proper metrics collection)
        let total_duration = metrics.average_duration.as_millis()
            * (metrics.requests_total - 1) as u128
            + duration.as_millis();
        metrics.average_duration =
            Duration::from_millis((total_duration / metrics.requests_total as u128) as u64);
    }

    /// Validate input against rules
    fn validate_input(&self, value: &str, rules: &ValidationRules) -> McpResult<()> {
        // Required validation
        if rules.required.unwrap_or(false) && value.is_empty() {
            return Err(McpError::invalid_request("Value is required but empty"));
        }

        // Length validation
        if let Some(min_len) = rules.min_length {
            if value.len() < min_len {
                return Err(McpError::invalid_request(format!(
                    "Value too short (min: {} chars, got: {})",
                    min_len,
                    value.len()
                )));
            }
        }

        if let Some(max_len) = rules.max_length {
            if value.len() > max_len {
                return Err(McpError::invalid_request(format!(
                    "Value too long (max: {} chars, got: {})",
                    max_len,
                    value.len()
                )));
            }
        }

        // Pattern validation (simplified - in production use proper regex crate)
        if let Some(pattern) = &rules.pattern {
            if pattern == "email" && !value.contains('@') {
                return Err(McpError::invalid_request("Invalid email format"));
            }
            if pattern == "url" && !value.starts_with("http") {
                return Err(McpError::invalid_request("Invalid URL format"));
            }
        }

        // Allowed values validation
        if let Some(allowed) = &rules.allowed_values {
            if !allowed.contains(&value.to_string()) {
                return Err(McpError::invalid_request(format!(
                    "Value not allowed. Allowed values: {allowed:?}"
                )));
            }
        }

        Ok(())
    }
}

impl AdvancedPatternsServer {
    /// Advanced HTTP request with circuit breaker and retry logic
    #[tool("Make HTTP request with advanced error handling and retry logic")]
    async fn advanced_http_request(&self, params: ApiRequest) -> McpResult<String> {
        let start_time = Instant::now();
        let operation_id = uuid::Uuid::new_v4().to_string();

        let _ = ctx
            .info(&format!(
                "Starting HTTP request to: {} (ID: {})",
                params.url, operation_id
            ))
            .await;

        // Validate URL format
        self.validate_input(
            &params.url,
            &ValidationRules {
                min_length: Some(10),
                max_length: Some(2048),
                pattern: Some("url".to_string()),
                required: Some(true),
                allowed_values: None,
            },
        )?;

        // Check circuit breaker
        if !self.circuit_breaker_allows().await {
            let _ = ctx
                .warn("Circuit breaker is OPEN - rejecting request")
                .await;
            return Err(McpError::internal(
                "External service is currently unavailable (circuit breaker open)",
            ));
        }

        let retry_attempts = params.retry_attempts.unwrap_or(3);
        let url = params.url.clone();
        let method = params.method.clone().unwrap_or_else(|| "GET".to_string());

        // Simplified retry logic without complex closures
        let mut attempts = 0;
        let mut delay = Duration::from_millis(100);
        let mut last_error = None;

        while attempts < retry_attempts {
            attempts += 1;
            let _ = ctx
                .info(&format!(
                    "Attempt {attempts}/{retry_attempts} for HTTP request"
                ))
                .await;

            // Simulate HTTP request (in real implementation, use reqwest or similar)
            tracing::info!(&format!("Making {method} request to {url}"));

            // Simulate network delay and potential failure
            sleep(Duration::from_millis(200 + (rand::random::<u64>() % 800)));

            // Simulate occasional failures for demonstration
            if rand::random::<u32>() % 5 == 0 {
                // Simulate 20% failure rate
                let error = McpError::internal("Simulated network error");
                last_error = Some(error.clone());

                if attempts >= retry_attempts {
                    let _ = ctx
                        .error(&format!(
                            "HTTP request failed after {attempts} attempts: {error}"
                        ))
                        .await;
                    let duration = start_time.elapsed();
                    self.update_circuit_breaker(false);
                    self.record_metrics(duration, false);
                    return Err(error);
                }

                let _ = ctx
                    .warn(&format!(
                        "Attempt {attempts} failed: {error}, retrying in {delay:?}"
                    ))
                    .await;
                sleep(delay);

                // Exponential backoff with jitter
                delay = Duration::from_millis((delay.as_millis() * 2).min(5000) as u64);
                delay += Duration::from_millis(50 + (rand::random::<u64>() % 100));
                continue;
            }

            // Success case
            let response = serde_json::json!({
                "status": 200,
                "method": method,
                "url": url,
                "timestamp": chrono::Utc::now().to_rfc3339(),
                "headers": {
                    "content-type": "application/json",
                    "server": "TurboMCP-Simulator"
                },
                "body": "Simulated successful response"
            });

            let duration = start_time.elapsed();
            self.update_circuit_breaker(true);
            self.record_metrics(duration, true);

            if attempts > 1 {
                let _ = ctx
                    .info(&format!("HTTP request succeeded after {attempts} attempts"))
                    .await;
            }
            let _ = ctx
                .info(&format!(
                    "HTTP request completed successfully in {duration:?}"
                ))
                .await;
            return Ok(response.to_string());
        }

        // This should never be reached, but just in case
        Err(last_error.unwrap_or_else(|| McpError::internal("Unknown error")))
    }

    /// Validate input with comprehensive rules
    #[tool("Validate input against comprehensive validation rules")]
    async fn validate_with_rules(
        &self,
        value: String,
        rules: ValidationRules,
    ) -> McpResult<String> {
        let _ = ctx
            .info(&format!("Validating value with {} rules", {
                let mut count = 0;
                if rules.min_length.is_some() {
                    count += 1;
                }
                if rules.max_length.is_some() {
                    count += 1;
                }
                if rules.pattern.is_some() {
                    count += 1;
                }
                if rules.required.is_some() {
                    count += 1;
                }
                if rules.allowed_values.is_some() {
                    count += 1;
                }
                count
            }))
            .await;

        // Perform validation
        self.validate_input(&value, &rules)?;

        tracing::info!("Input validation passed successfully");

        Ok(format!("✅ Input '{value}' passed all validation rules"))
    }

    /// Process data with advanced async patterns
    #[tool("Process data with advanced async patterns (parallelization, timeouts, cancellation)")]
    async fn advanced_processing(&self, task: ProcessingTask) -> McpResult<String> {
        let start_time = Instant::now();
        let operation_id = uuid::Uuid::new_v4().to_string();

        let _ = ctx
            .info(&format!(
                "Starting {} processing (ID: {})",
                task.task_type, operation_id
            ))
            .await;

        let timeout_duration = Duration::from_secs(task.timeout_seconds.unwrap_or(60));

        let result = timeout(timeout_duration, async {
            match task.task_type.as_str() {
                "cpu_intensive" => {
                    tracing::info!("Performing CPU-intensive computation");

                    if task.parallel.unwrap_or(false) {
                        // Parallel processing simulation
                        let chunks = task.chunks.unwrap_or(4);
                        let mut tasks = Vec::new();

                        for i in 0..chunks {
                            // Note: Context is not Clone, so we can't pass it to spawned tasks
                            tasks.push(tokio::spawn(async move {
                                tracing::info!("Processing chunk {}", i);
                                sleep(Duration::from_millis(100 + (rand::random::<u64>() % 200)))
                                    .await;
                                format!("chunk_{i}_result")
                            }));
                        }

                        let results: Vec<String> =
                            futures::future::try_join_all(tasks).await.map_err(|e| {
                                McpError::internal(format!("Parallel processing failed: {e}"))
                            })?;

                        Ok(format!("Parallel processing completed: {results:?}"))
                    } else {
                        // Sequential processing
                        sleep(Duration::from_millis(500));
                        Ok("CPU-intensive task completed sequentially".to_string())
                    }
                }
                "io_bound" => {
                    tracing::info!("Performing I/O-bound operations");

                    // Simulate multiple I/O operations
                    let mut results = Vec::new();
                    for i in 1..=3 {
                        tracing::info!(&format!("I/O operation {i}/3"));
                        sleep(Duration::from_millis(150));
                        results.push(format!("io_result_{i}"));
                    }

                    Ok(format!("I/O operations completed: {results:?}"))
                }
                "network" => {
                    let _ = ctx
                        .info("Performing network operations with error handling")
                        .await;

                    // Use circuit breaker for network operations
                    if !self.circuit_breaker_allows().await {
                        return Err(McpError::internal("Network services unavailable"));
                    }

                    // Simulate network operation with potential failure
                    sleep(Duration::from_millis(300));

                    if rand::random::<u32>() % 7 == 0 {
                        // Simulate 15% failure rate
                        self.update_circuit_breaker(false);
                        return Err(McpError::internal("Network operation failed"));
                    }

                    self.update_circuit_breaker(true);
                    Ok("Network operations completed successfully".to_string())
                }
                _ => Err(McpError::invalid_request(
                    "Unknown task type. Supported: cpu_intensive, io_bound, network",
                )),
            }
        })
        .await;

        let duration = start_time.elapsed();

        match result {
            Ok(inner_result) => match inner_result {
                Ok(message) => {
                    let _ = ctx
                        .info(&format!(
                            "Processing completed successfully in {duration:?}"
                        ))
                        .await;
                    self.record_metrics(duration, true);
                    Ok(message)
                }
                Err(e) => {
                    let _ = ctx
                        .error(&format!("Processing failed in {duration:?}: {e}"))
                        .await;
                    self.record_metrics(duration, false);
                    Err(e)
                }
            },
            Err(_) => {
                let _ = ctx
                    .error(&format!("Processing timed out after {duration:?}"))
                    .await;
                self.record_metrics(duration, false);
                Err(McpError::internal("Processing operation timed out"))
            }
        }
    }

    /// Get detailed server metrics and health status
    #[tool("Get comprehensive server metrics, circuit breaker status, and health information")]
    async fn get_advanced_metrics(&self) -> McpResult<String> {
        tracing::info!("Gathering comprehensive server metrics");

        let metrics = self.metrics.read();
        let circuit_breaker = self.circuit_breaker.lock();
        let active_ops = self.active_operations.read();

        let health_status = match circuit_breaker.state {
            CircuitState::Closed => "healthy",
            CircuitState::HalfOpen => "degraded",
            CircuitState::Open => "unhealthy",
        };

        let success_rate = if metrics.requests_total > 0 {
            (metrics.requests_successful as f64 / metrics.requests_total as f64) * 100.0
        } else {
            0.0
        };

        let detailed_metrics = serde_json::json!({
            "server_health": {
                "status": health_status,
                "uptime": "N/A", // Would track actual uptime in production
                "version": "1.0.0"
            },
            "request_metrics": {
                "total_requests": metrics.requests_total,
                "successful_requests": metrics.requests_successful,
                "failed_requests": metrics.requests_failed,
                "success_rate_percent": format!("{:.2}%", success_rate),
                "average_response_time": format!("{:?}", metrics.average_duration)
            },
            "circuit_breaker": {
                "state": format!("{:?}", circuit_breaker.state),
                "failure_count": circuit_breaker.failures,
                "last_failure": circuit_breaker.last_failure.map(|t| {
                    format!("{:?} ago", t.elapsed())
                })
            },
            "active_operations": {
                "count": active_ops.len(),
                "operation_ids": active_ops.keys().collect::<Vec<_>>()
            },
            "patterns_demonstrated": [
                "Circuit breaker pattern",
                "Retry with exponential backoff",
                "Input validation with custom rules",
                "Timeout handling",
                "Parallel processing",
                "Metrics collection",
                "Operation cancellation",
                "Comprehensive error handling"
            ]
        });

        Ok(detailed_metrics.to_string())
    }

    /// Cancel an active operation
    #[tool("Cancel an active operation by its ID")]
    async fn cancel_operation(&self, operation_id: String) -> McpResult<String> {
        let _ = ctx
            .info(&format!("Attempting to cancel operation: {operation_id}"))
            .await;

        let mut active_ops = self.active_operations.write();

        if let Some(cancel_tx) = active_ops.remove(&operation_id) {
            if cancel_tx.send(()).is_ok() {
                let _ = ctx
                    .info(&format!("Successfully cancelled operation: {operation_id}"))
                    .await;
                Ok(format!("Operation {operation_id} cancelled successfully"))
            } else {
                let _ = ctx
                    .warn(&format!("Operation {operation_id} was already completing"))
                    .await;
                Ok(format!("Operation {operation_id} was already completing"))
            }
        } else {
            Err(McpError::resource(
                "Operation not found or already completed",
            ))
        }
    }

    /// Simulate a controlled failure for testing error handling
    #[tool("Simulate various types of failures for testing error handling")]
    async fn simulate_failure(&self, failure_type: String) -> McpResult<String> {
        let _ = ctx
            .info(&format!("Simulating {failure_type} failure"))
            .await;

        match failure_type.as_str() {
            "timeout" => {
                sleep(Duration::from_secs(10)); // Will timeout if client timeout < 10s
                Ok("This should not be reached".to_string())
            }
            "invalid_request" => {
                Err(McpError::invalid_request("Simulated invalid request error"))
            }
            "internal_error" => {
                Err(McpError::internal("Simulated internal server error"))
            }
            "service_unavailable" => {
                Err(McpError::internal("Simulated service unavailable"))
            }
            "not_found" => {
                Err(McpError::resource("Simulated resource not found"))
            }
            "cancelled" => {
                Err(McpError::internal("Simulated operation cancelled"))
            }
            _ => {
                Err(McpError::invalid_request(
                    "Unknown failure type. Supported: timeout, invalid_request, internal_error, service_unavailable, not_found, cancelled"
                ))
            }
        }
    }
}

#[tokio::main]
async fn main() -> McpResult<()> {
    tracing_subscriber::fmt()
        .with_env_filter("info")
        .with_target(false)
        .with_thread_ids(true)
        .init();

    tracing::info!("🔥 Starting Advanced Patterns MCP Server");
    tracing::info!("========================================");
    tracing::info!("Patterns: Error handling, Circuit breakers, Retries, Validation");
    tracing::info!("Features: Timeouts, Cancellation, Metrics, Async patterns");

    let server = AdvancedPatternsServer::new();

    tracing::info!("Server ready! Try the advanced tools to see production patterns in action.");

    server
        .run_stdio()
        .await
        .map_err(|e| McpError::internal(format!("Server error: {e}")))
}

/* 🎯 **Try these advanced pattern examples:**

**HTTP with retry and circuit breaker:**
- advanced_http_request({"url": "https://httpbin.org/delay/1", "retry_attempts": 3, "timeout_seconds": 5})
- Try multiple failed requests to trigger circuit breaker

**Input validation:**
- validate_with_rules("test@example.com", {"pattern": "email", "min_length": 5, "required": true})
- validate_with_rules("short", {"min_length": 10}) // Should fail

**Advanced async processing:**
- advanced_processing({"task_type": "cpu_intensive", "parallel": true, "chunks": 8})
- advanced_processing({"task_type": "network", "timeout_seconds": 10})

**Metrics and monitoring:**
- get_advanced_metrics() // See server health and circuit breaker state

**Error handling examples:**
- simulate_failure("timeout") // Test timeout handling
- simulate_failure("invalid_request") // Test validation errors

**Key Production Patterns Demonstrated:**
✅ Circuit breaker pattern with automatic recovery
✅ Retry with exponential backoff and jitter
✅ Comprehensive input validation with custom rules
✅ Timeout handling with graceful degradation
✅ Operation cancellation and cleanup
✅ Parallel processing with error aggregation
✅ Metrics collection and health monitoring
✅ Structured error handling with context
✅ Resource management and leak prevention

**Next:** `06_authentication_security.rs` - Security, auth, and session management
*/
